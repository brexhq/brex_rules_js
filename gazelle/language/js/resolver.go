package js

import (
	"errors"
	"fmt"
	"log"
	"path"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const LanguageName = "js"

var (
	skipImportError = errors.New("std import")

	// builtinModule list taken from https://github.com/sindresorhus/builtin-modules/blob/master/builtin-modules.json
	BuiltinModules = []string{
		"assert",
		"async_hooks",
		"buffer",
		"child_process",
		"cluster",
		"console",
		"constants",
		"crypto",
		"dgram",
		"dns",
		"domain",
		"events",
		"fs",
		"http",
		"http2",
		"https",
		"inspector",
		"module",
		"net",
		"os",
		"path",
		"perf_hooks",
		"process",
		"punycode",
		"querystring",
		"readline",
		"repl",
		"stream",
		"string_decoder",
		"timers",
		"tls",
		"trace_events",
		"tty",
		"url",
		"util",
		"v8",
		"vm",
		"zlib",
	}

	IndexFiles = []string{
		"index",
	}

	WellKnownProtos = map[string]bool{
		"google/protobuf/any.proto":             true,
		"google/protobuf/api.proto":             true,
		"google/protobuf/compiler/plugin.proto": true,
		"google/protobuf/descriptor.proto":      true,
		"google/protobuf/duration.proto":        true,
		"google/protobuf/empty.proto":           true,
		"google/protobuf/field_mask.proto":      true,
		"google/protobuf/source_context.proto":  true,
		"google/protobuf/struct.proto":          true,
		"google/protobuf/timestamp.proto":       true,
		"google/protobuf/type.proto":            true,
		"google/protobuf/wrappers.proto":        true,
	}
)

func init() {
	sort.Strings(BuiltinModules)
}

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (s *JSLanguage) Name() string {
	return LanguageName
}

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (s *JSLanguage) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	var imports []resolve.ImportSpec

	cfg := GetConfig(c)
	rel := f.Pkg

	if MatchesAny(r.Kind(), "js_library", "ts_library", "babel_library") {
		srcs := r.AttrStrings("srcs")

		for _, src := range srcs {
			withoutSuffix := strings.TrimSuffix(src, path.Ext(src))
			imp := strings.ToLower(path.Join(rel, withoutSuffix))
			imp = cfg.WorkspacePath(imp)

			imports = append(imports, resolve.ImportSpec{
				Lang: LanguageName,
				Imp:  imp,
			})
		}
	} else if r.Kind() == "js_proto_library" {
		var protoRule *rule.Rule

		target, err := label.Parse(r.AttrString("proto"))

		if err != nil {
			log.Printf("%s/%s: %s", rel, r.Name(), err)
			return nil
		}

		if !target.Relative {
			log.Printf("%s/%s: %s", rel, r.Name(), "not relative")
			return nil
		}

		for _, other := range f.Rules {
			if other.Kind() == "proto_library" && other.Name() == target.Name {
				protoRule = other
				break
			}
		}

		if protoRule == nil {
			log.Printf("%s/%s: %s", rel, r.Name(), "proto not found")
			return nil
		}

		srcs := protoRule.AttrStrings("srcs")

		for _, src := range srcs {
			withoutSuffix := strings.TrimSuffix(src, path.Ext(src))
			imp := strings.ToLower(path.Join(rel, withoutSuffix))
			jsImp := cfg.WorkspacePath(imp)
		
			imports = append(imports, resolve.ImportSpec{
				Lang: "proto",
				Imp:  imp + ".proto",
			})

			imports = append(imports, resolve.ImportSpec{
				Lang: LanguageName,
				Imp:  jsImp + "_pb",
			})

			imports = append(imports, resolve.ImportSpec{
				Lang: LanguageName,
				Imp:  jsImp + "_grpc_pb",
			})
		}
	}

	return imports
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (s *JSLanguage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return []label.Label{}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. A list of imported libraries is typically stored in a
// private attribute of the rule when it's generated (this interface doesn't
// dictate how that is stored or represented). Resolve generates a "deps"
// attribute (or the appropriate language-specific equivalent) for each
// import according to language-specific rules and heuristics.
func (s *JSLanguage) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	cfg := GetConfig(c)
	imports := importsRaw.([]string)
	depset := make(map[string]bool)

	if MatchesAny(r.Kind(), "ts_library", "babel_library") {
		depset[cfg.NpmPath("@types")] = true
	}

	doResolve := resolveJs

	if r.Kind() == "js_proto_library" {
		doResolve = resolveProto
	}

	for _, imp := range imports {
		l, err := doResolve(c, ix, imp, from)

		if err == skipImportError {
			continue
		} else if err != nil {
			log.Print(err)
		}

		l = l.Rel(from.Repo, from.Pkg)
		depset[l.String()] = true
	}

	if len(depset) > 0 {
		deps := make([]string, 0, len(depset))

		for dep := range depset {
			deps = append(deps, dep)
		}

		sort.Strings(deps)

		r.SetAttr("deps", deps)
	}
}

func resolveJs(c *config.Config, ix *resolve.RuleIndex, imp string, from label.Label) (label.Label, error) {
	cfg := GetConfig(c)

	if cfg.IsBuiltinImport(imp) {
		return label.NoLabel, skipImportError
	}

	if l, ok := resolve.FindRuleWithOverride(c, resolve.ImportSpec{Lang: LanguageName, Imp: imp}, LanguageName); ok {
		return l, nil
	}

	imp = normaliseImports(cfg, imp, ix, from)

	l, found, err := resolveWithIndex(ix, imp, from)

	if err != nil {
		return label.NoLabel, err
	}

	if found {
		return l, nil
	}

	for _, indexFile := range IndexFiles {
		indexImport := path.Join(imp, indexFile)
		l, f, err := resolveWithIndex(ix, indexImport, from)

		if err != nil {
			continue
		}

		if f {
			return l, nil
		}
	}

	if isNpmDependency(imp) {
		s := strings.Split(imp, "/")
		pkg := s[0]

		if pkg != cfg.WorkspaceName {
			if strings.HasPrefix(imp, "@") {
				pkg += "/" + s[1]
			}

			return label.New(cfg.NpmWorkspaceName, pkg, path.Base(pkg)), nil
		}
	}

	return label.NoLabel, fmt.Errorf("Import %v for %s not found.\n", imp, from.Abs(from.Repo, from.Pkg).String())
}

func resolveProto(c *config.Config, ix *resolve.RuleIndex, imp string, from label.Label) (label.Label, error) {
	if WellKnownProtos[imp] {
		return label.NoLabel, skipImportError
	}

	if l, ok := resolve.FindRuleWithOverride(c, resolve.ImportSpec{Lang: "proto", Imp: imp}, LanguageName); ok {
		return l, nil
	}

	l, found, err := resolveWithIndexProto(ix, imp, from)

	if err != nil {
		return label.NoLabel, err
	}

	if found {
		return l, nil
	}

	return label.NoLabel, fmt.Errorf("Import %v for %s not found.\n", imp, from.Abs(from.Repo, from.Pkg).String())
}

// normaliseImports ensures that relative imports or alias imports can all resolve to the same file
func normaliseImports(cfg *Config, imp string, ix *resolve.RuleIndex, from label.Label) string {
	pkgDir := from.Pkg

	if HasAnyPrefix(imp, "./", "../") {
		imp = path.Join(pkgDir, imp)

		return cfg.WorkspacePath(imp)
	}

	return imp
}

func isNpmDependency(imp string) bool {
	return !HasAnyPrefix(imp, "./", "/", "../", "~/", "@/", "~~/")
}

func resolveWithIndex(ix *resolve.RuleIndex, imp string, from label.Label) (label.Label, bool, error) {
	res := resolve.ImportSpec{
		Lang: LanguageName,
		Imp:  imp,
	}

	matches := ix.FindRulesByImport(res, LanguageName)

	if len(matches) == 0 {
		return label.NoLabel, false, nil
	}

	if len(matches) > 1 {
		return label.NoLabel, false, fmt.Errorf("multiple rules (%s and %s) may be imported with %q from %s", matches[0].Label, matches[1].Label, imp, from)
	}

	if matches[0].IsSelfImport(from) {
		return label.NoLabel, false, skipImportError
	}

	return matches[0].Label, true, nil
}

func resolveWithIndexProto(ix *resolve.RuleIndex, imp string, from label.Label) (label.Label, bool, error) {
	res := resolve.ImportSpec{
		Lang: "proto",
		Imp:  imp,
	}

	matches := ix.FindRulesByImport(res, LanguageName)

	if len(matches) == 0 {
		return label.NoLabel, false, nil
	}

	if len(matches) > 1 {
		return label.NoLabel, false, fmt.Errorf("multiple rules (%s and %s) may be imported with %q from %s", matches[0].Label, matches[1].Label, imp, from)
	}

	if matches[0].IsSelfImport(from) {
		return label.NoLabel, false, skipImportError
	}

	return matches[0].Label, true, nil
}
