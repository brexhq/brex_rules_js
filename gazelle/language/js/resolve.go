package js

import (
	"log"
	"path"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const LanguageName = "js"

var (
	IndexFiles = []string{
		"index",
	}
)

// Name returns the name of the language. This should be a prefix of the
// kinds of rules generated by the language, e.g., "go" for the Go extension
// since it generates "go_library" rules.
func (s *JSLanguage) Name() string {
	return LanguageName
}

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (s *JSLanguage) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	var imports []resolve.ImportSpec

	cfg := GetConfig(c)
	rel := f.Pkg
	packageName := buildPackageName(cfg, rel, r)

	if MatchesAny(r.Kind(), "js_library", "ts_library", "babel_library") {
		srcs := r.AttrStrings("srcs")

		for _, src := range srcs {
			moduleName := strings.TrimSuffix(src, path.Ext(src))
			imp := strings.ToLower(path.Join(packageName, moduleName))

			imports = append(imports, resolve.ImportSpec{
				Lang: LanguageName,
				Imp:  imp,
			})
		}
	} else if r.Kind() == "js_proto_library" {
		var protoRule *rule.Rule

		target, err := label.Parse(r.AttrString("proto"))

		if err != nil {
			log.Printf("%s/%s: %s", rel, r.Name(), err)
			return nil
		}

		if !target.Relative {
			log.Printf("%s/%s: %s", rel, r.Name(), "not relative")
			return nil
		}

		for _, other := range f.Rules {
			if other.Kind() == "proto_library" && other.Name() == target.Name {
				protoRule = other
				break
			}
		}

		if protoRule == nil {
			log.Printf("%s/%s: %s", rel, r.Name(), "proto not found")
			return nil
		}

		srcs := protoRule.AttrStrings("srcs")

		for _, src := range srcs {
			moduleName := strings.TrimSuffix(src, path.Ext(src))
			imp := strings.ToLower(path.Join(rel, moduleName))
			jsImp := strings.ToLower(path.Join(packageName, moduleName))

			imports = append(imports, resolve.ImportSpec{
				Lang: "proto",
				Imp:  imp + ".proto",
			})

			imports = append(imports, resolve.ImportSpec{
				Lang: "js",
				Imp:  jsImp + "_pb",
			})

			imports = append(imports, resolve.ImportSpec{
				Lang: "js",
				Imp:  jsImp + "_grpc_pb",
			})
		}
	}

	return imports
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (s *JSLanguage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return []label.Label{}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. A list of imported libraries is typically stored in a
// private attribute of the rule when it's generated (this interface doesn't
// dictate how that is stored or represented). Resolve generates a "deps"
// attribute (or the appropriate language-specific equivalent) for each
// import according to language-specific rules and heuristics.
func (s *JSLanguage) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, importsRaw interface{}, from label.Label) {
	if importsRaw == nil {
		return
	}

	cfg := GetConfig(c)
	imports := importsRaw.([]Import)
	depset := make(map[string]bool)

	if MatchesAny(r.Kind(), "ts_library", "babel_library") {
		depset[cfg.NpmPath("@types")] = true
	}

	doResolve := resolveJs

	if r.Kind() == "js_proto_library" {
		doResolve = resolveProto
	}

	for _, imp := range imports {
		l, err := doResolve(c, ix, imp, from)

		if err == SkipImportError {
			continue
		} else if err != nil {
			log.Print(err)
			continue
		}

		l = l.Rel(from.Repo, from.Pkg)
		depset[l.String()] = true
	}

	if len(depset) > 0 {
		deps := make([]string, 0, len(depset))

		for dep := range depset {
			deps = append(deps, dep)
		}

		sort.Strings(deps)

		r.SetAttr("deps", deps)
	}
}
func resolveJs(c *config.Config, ix *resolve.RuleIndex, imp Import, from label.Label) (label.Label, error) {
	if BuiltinModules[imp.Import] {
		return label.NoLabel, SkipImportError
	}

	r := NewResolver(c, ix, "js", IndexFiles)

	imp = normaliseImports(imp)

	return resolveOrFail(
		imp,
		from,
		r.ResolveOverride,
		r.ResolveWithIndex,
		r.ResolveDefaultImport,
		r.ResolveWildcard,
		r.ResolveNpm,
	)
}

func resolveProto(c *config.Config, ix *resolve.RuleIndex, imp Import, from label.Label) (label.Label, error) {
	if WellKnownProtos[imp.Import] {
		return label.NoLabel, SkipImportError
	}

	r := NewResolver(c, ix, "proto", nil)

	imp = normaliseImports(imp)

	return resolveOrFail(
		imp,
		from,
		r.ResolveOverride,
		r.ResolveWithIndex,
	)
}
